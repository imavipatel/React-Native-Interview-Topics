/********************************************************************
 * ðŸ§° Reducing App Size â€” Hermes, ProGuard/R8, Resource Configs, Asset Compression
 * ------------------------------------------------------------------
 * JS-Style Notes â€” Practical, New-Architecture Friendly (Fabric / TurboModules / JSI)
 *
 * Covers:
 *  - Hermes (bytecode, precompile)
 *  - ProGuard / R8 (minify, keep rules, mapping)
 *  - Resource configs (resConfigs, remove locales, shrinkResources)
 *  - Asset compression & strategies (images, fonts, audio, video)
 *  - ABI / bundle split strategies, debug symbol handling
 *  - Best practices, CI tips, and quick Q&A
 ********************************************************************/

/* ============================================================
 * ðŸ”¹ OVERVIEW â€” WHY SIZE MATTERS
 * ============================================================
 * - Smaller apps: faster downloads, lower storage, better installs.
 * - Play/App Store and users favor smaller binary sizes.
 * - New Arch: include native libs (TurboModules/JSI) â€” ensure they are built/split properly.
 */

/* ============================================================
 * 1) HERMES â€” JS ENGINE OPTIMIZATIONS
 * ============================================================
 *
 * What Hermes does:
 * - Hermes compiles JS to optimized bytecode ahead-of-time (AOT) or at runtime.
 * - Hermes bundles are smaller and faster to start (lower JIT overhead).
 *
 * Enable Hermes (Android):
 * // android/app/build.gradle (project level RN config or gradle.properties)
 * project.ext.react = [
 *   enableHermes: true,  // clean && rebuild required after change
 * ]
 *
 * Enable Hermes (iOS, RN >= 0.64+ with Hermes support):
 * // ios/Podfile - enable Hermes engine build if supported by RN template
 *
 * Hermes bytecode tips:
 * - Precompile Hermes bytecode in CI for faster cold start (some setups produce .hbc files).
 * - Ensure OTA systems (EAS) / CodePush are compatible with Hermes bytecode if you precompile.
 *
 * Caveats:
 * - Precompiled bytecode ties the JS runtime; ensure runtime/version parity.
 * - Test thoroughly for native module compatibility with Hermes.
 */

/* ============================================================
 * 2) PROGUARD / R8 â€” CODE SHRINKING & OBFUSCATION
 * ============================================================
 *
 * What R8/ProGuard does:
 * - Removes unused Java/Kotlin classes & methods (shrink).
 * - Renames classes/methods (obfuscate).
 * - Can remove unused resources with shrinkResources.
 *
 * Enable in build.gradle:
 * android {
 *   buildTypes {
 *     release {
 *       minifyEnabled true            // enable R8
 *       shrinkResources true          // remove unused resources
 *       proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
 *     }
 *   }
 * }
 *
 * Common ProGuard rules (keep RN / TurboModule essentials):
 * -keep class com.facebook.react.** { *; }
 * -keep class com.facebook.jni.** { *; }
 * -keepclassmembers class * {
 *     @com.facebook.react.bridge.ReactMethod <methods>;
 * }
 * # Keep native module spec classes generated by codegen
 * -keep class *Native*Module* { *; }
 *
 * Tips:
 * - Always upload mapping.txt to Play Console to deobfuscate traces.
 * - Test release builds thoroughly â€” R8 may strip reflective or annotation-based code.
 */

/* ============================================================
 * 3) RESOURCE CONFIGS â€” REMOVE UNUSED LOCALES & DENSITIES
 * ============================================================
 *
 * Remove unused locales & densities in Gradle:
 * android {
 *   defaultConfig {
 *     // Keep only en + your locales
 *     resConfigs "en", "es", "fr"
 *   }
 * }
 *
 * Remove unused drawable densities (if you supply only xxhdpi/xxxhdpi):
 * android {
 *   defaultConfig {
 *     // Optionally keep only common densities to reduce APK install size
 *     // resConfigs does not control densities; prune assets at build time
 *   }
 * }
 *
 * shrinkResources = true (works with minifyEnabled). It removes resources unreachable from code.
 *
 * For iOS:
 * - Use Asset Catalogs (.xcassets) to enable App Thinning / slicing
 * - Remove unsupported device idiom assets, unused image sets
 */

/* ============================================================
 * 4) ASSET COMPRESSION STRATEGIES
 * ============================================================
 *
 * Images:
 * - Convert PNG â†’ WebP (Android) for lower size (lossy or lossless).
 * - Use 1x/2x/3x only when required; prefer single high-res + Image scaling.
 * - Use vector graphics (SVG or react-native-svg) for icons instead of bitmaps.
 * - Use PNG quantization tools (pngquant) and WebP conversion in CI.
 *
 * Example (convert to WebP in CI):
 * - webp:- cwebp input.png -q 80 -o output.webp
 *
 * Fonts:
 * - Subset fonts to include only used glyphs (Google Fonts subset tools).
 * - Prefer system fonts when possible to avoid bundling large font files.
 *
 * Audio/Video:
 * - Use streaming (HLS/DASH) instead of bundling large media.
 * - If bundling is required, encode with efficient codecs and lower bitrates.
 *
 * Assets bundling tips:
 * - Keep large assets remote (CDN) and download on demand.
 * - Use lazy download + cache to avoid packaging large blobs in the binary.
 */

/* ============================================================
 * 5) ABI / APP BUNDLE / SPLITS
 * ============================================================
 *
 * Use App Bundle (AAB):
 * - Prefer AAB so Play will serve device-specific APKs (split by ABI, density, language).
 * - This reduces the installed size per device.
 *
 * ABI splits (if not using AAB):
 * android {
 *   splits {
 *     abi {
 *       enable true
 *       reset()
 *       include 'armeabi-v7a', 'arm64-v8a'
 *       universalApk false
 *     }
 *   }
 * }
 *
 * NDK & native libs:
 * - Build native libraries (.so) only for ABIs you support.
 * - For TurboModules / JSI native libs, ensure multi-ABI build artifacts are produced (or split).
 *
 * VersionCode considerations:
 * - If producing multiple APKs (ABI split), ensure unique versionCode per APK.
 */

/* ============================================================
 * 6) STRIP DEBUG & NATIVE SYMBOLS (REDUCE NATIVE SIZE)
 * ============================================================
 *
 * - Strip debug symbols from native libraries to reduce size:
 *   ndk {
 *     debugSymbolLevel 'none' // or 'full'/'split' depending on needs
 *   }
 *
 * - For release builds, upload native debug symbols to Play Console for crash deobfuscation.
 * - For iOS, include dSYM uploading to Sentry / App Store Connect but do not embed unstripped dSYM in the shipped app.
 *
 * - Removing unnecessary native resources (libs for emulators or debug only) helps reduce size.
 */

/* ============================================================
 * 7) PACKAGING OPTIONS & EXCLUDE RULES
 * ============================================================
 *
 * In Gradle, exclude unneeded files from APK:
 * android {
 *   packagingOptions {
 *     exclude 'META-INF/*'
 *     exclude 'LICENSE'
 *     exclude '**/ lib / x86;
/*'   // if not supporting x86 on device
 *   }
 * }
 *
 * Remove debug-only resources from release builds (flipper, debug libs):
 * if (project.hasProperty('release')) {
 *   // remove debug libs via packagingOptions or Gradle conditions
 * }
 *
 * For node_modules that ship large files, consider removing test fixtures in CI before bundling.
 */

/* ============================================================
 * 8) BUNDLE & JS SIZE REDUCTIONS
 * ============================================================
 *
 * - Tree-shaking: use ES module imports and let bundler (Metro) eliminate dead code.
 * - Avoid large dependencies; prefer smaller modular libraries.
 * - Use code-splitting / lazy-loading (React.lazy + Suspense for RN where supported).
 * - Remove console logs and dev-only code in production builds.
 *   Example: use Babel plugin transform-remove-console for production.
 *
 * Metro settings:
 * - Enable inline requires (improves startup, reduces initial bundle parse cost)
 *   // android/app/proguard / metro.config.js
 *   transformer: { enableBabelRCLookup: false, inlineRequires: true }
 *
 * - Precompile Hermes bytecode to reduce runtime parsing overhead (and optionally size).
 */

/* ============================================================
 * 9) CI / AUTOMATION TIPS (Make size reductions repeatable)
 * ============================================================
 *
 * - Add asset optimization step in CI:
 *   â€¢ Convert large PNGs to WebP
 *   â€¢ Subset fonts
 *   â€¢ Remove unused locales/resources
 *
 * - Build release artifacts in CI:
 *   â€¢ ./gradlew bundleRelease
 *   â€¢ Capture output size & publish to artifact server for tracking
 *
 * - Keep a "size budget" check in CI: fail if AAB/APK > threshold
 *   â€¢ Use `du -sh android/app/build/outputs/bundle/release/app-release.aab`
 *
 * - Use git-lfs for huge assets (if they must be versioned) or better: keep assets on CDN
 */

/* ============================================================
 * 10) iOS-SPECIFIC TIPS (APP THINNING)
 * ============================================================
 *
 * - Use Asset Catalogs (xcassets) so App Thinning (slicing) works.
 * - Avoid bundling multiple large image variants; rely on 1x/2x/3x + slicing.
 * - Bitcode is deprecated for new apps â€” do not rely on it for size reductions.
 * - Use on-demand resources (ODR) for very large assets (games / huge media).
 */

/* ============================================================
 * 11) SUMMARY CHECKLIST (Quick wins)
 * ============================================================
 * âœ… Enable Hermes (test thoroughly)
 * âœ… Turn on R8/ProGuard (minifyEnabled true, shrinkResources true)
 * âœ… Use AAB (App Bundle) for Play Store
 * âœ… Convert images to WebP and subset fonts
 * âœ… Remove unused locales/resources (resConfigs)
 * âœ… Exclude debug/test files in packagingOptions
 * âœ… Lazy-load large modules & enable inlineRequires
 * âœ… Precompile Hermes bytecode (CI) if using Hermes AOT
 * âœ… Strip/handle native debug symbols separately (upload to Play)
 * âœ… Track size in CI & set thresholds
 */

/* ============================================================
 * QUICK Q&A (INTERVIEW READY)
 * ============================================================
 * Q: What are the main benefits of Hermes for app size and start time?
 * A: Hermes produces precompiled bytecode, reducing JS parsing cost and often producing smaller runtime artifact sizes and faster cold starts.
 *
 * Q: Why enable shrinkResources along with minifyEnabled?
 * A: R8/ProGuard shrinks code; shrinkResources removes unreachable resources that are no longer referenced â€” both together produce maximum reductions.
 *
 * Q: When should we use ABI splits vs App Bundle?
 * A: Prefer App Bundle (AAB) so Play serves optimized APKs. Use ABI splits only if you must distribute APKs manually or for special CI testing.
 *
 * Q: How to reduce size of bundled fonts?
 * A: Subset fonts (glyphs used), use system fonts where possible, and avoid bundling many full-weight font families.
 *
 * Q: Any pitfalls to watch for after shrinking/obfuscation?
 * A: Reflection-based code, annotations, or codegen-generated classes may be stripped â€” add keep rules in proguard-rules.pro and test release builds.
 *
 * ============================================================
 */
